<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        canvas {
            background: #000;
        }
    </style>
</head>
<body>
    <script>
        var stage = createRenderer(640, 480, document.body);

        var lightMap = createRenderer(640, 480);

        var map = {
            width: 40,
            height: 30,
            tileWidth: 16,
            tileHeight: 16,
            data: [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        };

        var light = {
            x: 320,
            y: 320
        };

//        light.x = 511; light.y = 436;
//        light.x = 573; light.y = 360;

//        var corners = calculateCornersCenter();
        var corners = calculateCorners();



        function createRenderer(width, height, appendTo) {
            var renderer = {};
            renderer.width = width;
            renderer.height = height;
            renderer.canvas = document.createElement("canvas");
            renderer.canvas.width = 640;
            renderer.canvas.height = 640;
            renderer.ctx = renderer.canvas.getContext("2d");

            if (appendTo) {
                appendTo.appendChild(renderer.canvas);
            }

            return renderer;
        }


        function calculateCornersCenter() {
            // Find the corners
            var corners = [];

            for (var y = 0; y < map.height; y++) {
                for (var x = 0; x < map.width; x++) {
                    // Skip edges?
                    if (y === 0 || x === 0 || y === map.height - 1 || x === map.width - 1) {
                        continue;
                    }

                    // Check top left
                    if (map.data[y][x] && !map.data[y][x - 1] && !map.data[y - 1][x] && !map.data[y - 1][x - 1]) {
                        corners.push({
                            x: (x * map.tileWidth) + (0.5 * map.tileWidth),
                            y: (y * map.tileHeight) + (0.5 * map.tileHeight)
                        });
                    }

                    if (!map.data[y][x] && map.data[y - 1][x] && map.data[y][x - 1] && map.data[y - 1][x - 1]) {
                        corners.push({
                            x: (x * map.tileWidth) - (0.5 * map.tileWidth),
                            y: (y * map.tileHeight) - (0.5 * map.tileHeight)
                        });
                    }

                    // Check top right
                    if (map.data[y][x] && !map.data[y][x + 1] && !map.data[y - 1][x] && !map.data[y - 1][x + 1]) {
                        corners.push({
                            x: ((x + 1) * map.tileWidth) - (0.5 * map.tileWidth),
                            y: (y * map.tileHeight) + (0.5 * map.tileHeight)
                        });
                    }

                    if (!map.data[y][x] && map.data[y - 1][x] && map.data[y][x + 1] && map.data[y - 1][x + 1]) {
                        corners.push({
                            x: ((x + 1) * map.tileWidth) + (0.5 * map.tileWidth),
                            y: (y * map.tileHeight) - (0.5 * map.tileHeight)
                        });
                    }

                    // Check bottom left
                    if (map.data[y][x] && !map.data[y][x - 1] && !map.data[y + 1][x] && !map.data[y + 1][x - 1]) {
                        corners.push({
                            x: (x * map.tileWidth) + (0.5 * map.tileWidth),
                            y: ((y + 1) * map.tileHeight) - (0.5 * map.tileHeight)
                        });
                    }

                    if (!map.data[y][x] && map.data[y + 1][x] && map.data[y][x - 1] && map.data[y + 1][x - 1]) {
                        corners.push({
                            x: (x * map.tileWidth) - (0.5 * map.tileWidth),
                            y: ((y + 1) * map.tileHeight) + (0.5 * map.tileHeight)
                        });
                    }

                    // Check bottom right
                    if (map.data[y][x] && !map.data[y][x + 1] && !map.data[y + 1][x] && !map.data[y + 1][x + 1]) {
                        corners.push({
                            x: ((x + 1) * map.tileWidth) - (0.5 * map.tileWidth),
                            y: ((y + 1) * map.tileHeight) - (0.5 * map.tileHeight)
                        });
                    }

                    if (!map.data[y][x] && map.data[y + 1][x] && map.data[y][x + 1] && map.data[y + 1][x + 1]) {
                        corners.push({
                            x: ((x + 1) * map.tileWidth) + (0.5 * map.tileWidth),
                            y: ((y + 1) * map.tileHeight) + (0.5 * map.tileHeight)
                        });
                    }
                }
            }

            // TODO: Remove duplicates?

            return corners;
        }

        function calculateCorners() {
            // Find the corners
            var corners = [];

            for (var y = 0; y < map.height; y++) {
                for (var x = 0; x < map.width; x++) {
                    // Skip edges?
                    if (y === 0 || x === 0 || y === map.height - 1 || x === map.width - 1) {
                        continue;
                    }

                    // Check top left
                    if ((map.data[y][x] && !map.data[y][x - 1] && !map.data[y - 1][x] && !map.data[y - 1][x - 1]) ||
                        !map.data[y][x] && map.data[y - 1][x] && map.data[y][x - 1] && map.data[y - 1][x - 1]) {
                        corners.push({
                            x: x * map.tileWidth,
                            y: y * map.tileHeight
                        });
                    }

                    // Check top right
                    if ((map.data[y][x] && !map.data[y][x + 1] && !map.data[y - 1][x] && !map.data[y - 1][x + 1]) ||
                        (!map.data[y][x] && map.data[y - 1][x] && map.data[y][x + 1] && map.data[y - 1][x + 1])) {
                        corners.push({
                            x: (x + 1) * map.tileWidth,
                            y: y * map.tileHeight
                        });
                    }

                    // Check bottom left
                    if ((map.data[y][x] && !map.data[y][x - 1] && !map.data[y + 1][x] && !map.data[y + 1][x - 1]) ||
                        (!map.data[y][x] && map.data[y + 1][x] && map.data[y][x - 1] && map.data[y + 1][x - 1])) {
                        corners.push({
                            x: x * map.tileWidth,
                            y: (y + 1) * map.tileHeight
                        });
                    }

                    // Check bottom right
                    if ((map.data[y][x] && !map.data[y][x + 1] && !map.data[y + 1][x] && !map.data[y + 1][x + 1]) ||
                        (!map.data[y][x] && map.data[y + 1][x] && map.data[y][x + 1] && map.data[y + 1][x + 1])) {
                        corners.push({
                            x: (x + 1) * map.tileWidth,
                            y: (y + 1) * map.tileHeight
                        });
                    }
                }
            }

            return corners;
        }

        function generateIntersections(x, y) {
            var intersections = [];
            var angle = 0.01;

            for (var c = 0, c1 = corners.length; c < c1; c++) {
                var intersection = rayTraceByAngle(x, y, corners[c].x, corners[c].y, 0 - angle);
                if (intersection) {
                    intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                    intersections.push(intersection);
                }

                intersection = rayTrace(x, y, corners[c].x, corners[c].y);
                if (intersection) {
                    intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                    intersections.push(intersection);
                }

                intersection = rayTraceByAngle(x, y, corners[c].x, corners[c].y, angle);
                if (intersection) {
                    intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                    intersections.push(intersection);
                }
            }

            intersection = rayTrace(x, y, x, y - 1000);
            if (intersection) {
                intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                intersections.push(intersection);
            }

            intersection = rayTrace(x, y, x, y + 1000);
            if (intersection) {
                intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                intersections.push(intersection);
            }

            intersection = rayTrace(x, y, x - 1000, y);
            if (intersection) {
                intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                intersections.push(intersection);
            }

            intersection = rayTrace(x, y, x + 1000, y);
            if (intersection) {
                intersection.angle = Math.atan2(x - intersection.x, y - intersection.y);
                intersections.push(intersection);
            }

                        // Remove duplicates
                        var deDupe = {};

                        for (var i = 0, m = intersections.length; i < m; i++) {
                            var key = intersections[i].x + "|" + intersections[i].y;
                            deDupe[key] = intersections[i];
                        }

                        intersections = [];
                        for (var k in deDupe) {
                            if (deDupe.hasOwnProperty(k)) {
                                intersections.push(deDupe[k]);
                            }
                        }

            // Sort by angle
            intersections.sort(function (a, b) {
                return a.angle - b.angle;
            });

            return intersections;
        }

        function rayTraceByAngle(x0, y0, x1, y1, angle) {
            var px = Math.cos(angle) * (x1 - x0) - Math.sin(angle) * (y1 - y0) + x0;
            var py = Math.sin(angle) * (x1 - x0) + Math.cos(angle) * (y1 - y0) + y0;

            return rayTrace(x0, y0, px, py);
        }

        function rayTrace(x0, y0, x1, y1) {
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var x = x0;
            var y = y0;
//            var n = 1 + dx + dy;    // max draw distance
            var n = 1000;
            var xInc = (x1 > x0) ? 1 : -1;
            var yInc = (y1 > y0) ? 1 : -1;
            var error = dx - dy;
            dx = dx * 2;
            dy = dy * 2;

            for (; n > 0; --n) {
                var mX = Math.floor(x / map.tileWidth);
                var mY = Math.floor(y / map.tileHeight);

                if ((x === x1 && y === y1) || (map.data[mY] && map.data[mY][mX])) {
                    return {
                        x: x,
                        y: y
                    };
                }

                if (error > 0) {
                    x += xInc;
                    error -= dy;
                } else {
                    y += yInc;
                    error += dx;
                }
            }

            return {
                x: x1,
                y: y1
            };
        }


        function render() {
            lightMap.ctx.clearRect(0, 0, lightMap.width, lightMap.height);

            stage.ctx.clearRect(0, 0, stage.width, stage.height);
            renderMap();

//            renderCorners();
            renderCircle(light.x, light.y, "red");
            renderCircle(light.x + 7, light.y, "red");
            renderCircle(light.x - 7, light.y, "red");
            renderCircle(light.x, light.y + 7, "red");
            renderCircle(light.x, light.y - 7, "red");

            var allIntersections = [];
            allIntersections.push( generateIntersections(light.x, light.y) );
            allIntersections.push( generateIntersections(light.x + 7, light.y) );
            allIntersections.push( generateIntersections(light.x - 7, light.y) );
            allIntersections.push( generateIntersections(light.x, light.y + 7) );
            allIntersections.push( generateIntersections(light.x, light.y - 7) );
            allIntersections.push(generateIntersections(light.x + 5, light.y + 5));
            allIntersections.push(generateIntersections(light.x - 5, light.y - 5));
            allIntersections.push(generateIntersections(light.x + 5, light.y - 5));
            allIntersections.push(generateIntersections(light.x - 5, light.y + 5));

            for (var i = 0, m = allIntersections.length; i < m; i++) {
                renderRayPolygon(allIntersections[i], lightMap.ctx);
            }

            stage.ctx.globalCompositeOperation = "destination-in";
            stage.ctx.drawImage(lightMap.canvas, 0, 0);
            stage.ctx.globalCompositeOperation = "source-over";
        }

        function renderRayLines(intersections, x, y) {
            stage.ctx.fillStyle = "red";
            stage.ctx.strokeStyle = "red";

            for (var i = 0, m = intersections.length; i < m; i++) {
//                stage.ctx.beginPath();
//                stage.ctx.moveTo(x, y);
//                stage.ctx.lineTo(intersections[i].x, intersections[i].y);
//                stage.ctx.stroke();

                renderCircle(intersections[i].x, intersections[i].y, "red");
            }
        }

        function renderRayPolygon(intersections, ctx) {
            ctx.fillStyle = "rgba(255,0,0,0.3)";
            ctx.strokeStyle = "blue";
            ctx.beginPath();

            ctx.moveTo(intersections[0].x, intersections[0].y);

            for (var i = 0, m = intersections.length; i < m; i++) {
                if (i === 0) {
                    ctx.lineTo(intersections[m - 1].x, intersections[m - 1].y);
                } else {
                    ctx.lineTo(intersections[i - 1].x, intersections[i - 1].y);
                }
            }

            ctx.fill();
//            stage.ctx.stroke();
        }


        function renderCircle(x, y, colour) {
            stage.ctx.fillStyle = colour;
            stage.ctx.beginPath();
            stage.ctx.arc(x, y, 3, 0, Math.PI * 2);
            stage.ctx.fill();
        }

        function renderCorners() {
            for (var c = 0, m = corners.length; c < m; c++) {
                renderCircle(corners[c].x, corners[c].y, "yellow");
            }
        }

        function renderMap() {
            stage.ctx.strokeStyle = "#eee";
            stage.ctx.fillStyle = "#999";

            for (var y = 0; y < map.height; y++) {
                for (var x = 0; x < map.width; x++) {
                    if (map.data[y][x]) {
                        stage.ctx.fillStyle = "#999";
                        stage.ctx.fillRect(x * map.tileWidth, y * map.tileHeight, map.tileWidth, map.tileHeight);
                    } else {
                        stage.ctx.fillStyle = "#ddd";
                        stage.ctx.fillRect(x * map.tileWidth, y * map.tileHeight, map.tileWidth, map.tileHeight);
                        stage.ctx.strokeRect(x * map.tileWidth, y * map.tileHeight, map.tileWidth, map.tileHeight);
                    }
                }
            }
        }

        render();

//        stage.canvas.addEventListener("click", function (e) {
        stage.canvas.addEventListener("mousemove", function (e) {
            light.x = e.x;
            light.y = e.y;
//            console.log(light);
            render();
        });
    </script>
</body>
</html>