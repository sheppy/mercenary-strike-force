<!DOCTYPE>
<html>
<head>
    <style>
        body {background:#eee; margin:0;}
        canvas {background:#fff;}
    </style>
</head>
<body>
<script>
    // http://greweb.me/2012/05/illuminated-js-2d-lights-and-shadows-rendering-engine-for-html5-applications/
    var canvas = document.createElement("canvas");
    canvas.width = 640;
    canvas.height = 480;
    document.body.appendChild(canvas);
    var ctx = canvas.getContext("2d");


    var lightMap = document.createElement("canvas");
    lightMap.width = 640;
    lightMap.height = 480;
    var lightMapCtx = lightMap.getContext("2d");

    var shadowMap = document.createElement("canvas");
    shadowMap.width = 640;
    shadowMap.height = 480;
    var shadowMapCtx = shadowMap.getContext("2d");


    var lightSourceMap = document.createElement("canvas");
    lightSourceMap.width = 640;
    lightSourceMap.height = 480;
    var lightSourceMapCtx = lightSourceMap.getContext("2d");

    var fog = document.createElement("canvas");
    fog.width = 640;
    fog.height = 480;
    var fogCtx = fog.getContext("2d");


    var visCircle = document.createElement("canvas");
    visCircle.width = 320;
    visCircle.height = 320;
    var visCircleCtx = visCircle.getContext("2d");
    var grd = ctx.createRadialGradient(160,160,20,160,160,160);

    grd.addColorStop(0,"rgba(233,233,162,0.7)");
    grd.addColorStop(0.8,"rgba(233,233,162,0.1)");
    grd.addColorStop(1,"rgba(233,233,162,0)");


//    grd.addColorStop(0,"rgba(255,0,255,1)");
//    grd.addColorStop(1,"rgba(255,0,255,1)");

    visCircleCtx.fillStyle = grd;
    visCircleCtx.beginPath()
    visCircleCtx.arc(160, 160, 160, 0, Math.PI * 2);
    visCircleCtx.fill();


    var tileWidth = tileHeight = 32;
    var mapWidth = 20,
        mapHeight = 15;
    var map = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    var corners = [];
        findCorners();
    var intersections = [];

    var mouseX = 0,
        mouseY = 0;

    var lightX = 320,
        lightY = 320;


    canvas.addEventListener("mousemove", function (e) {
        //console.log(e.x, e.y);
        mouseX = lightX = e.x;
        mouseY = lightY = e.y;
        render();
    });


    /*
        Before drawing the light polygon - process all lights?
        Problem them becomes disconnected lights :(
    */

    function render() {
        // Draw red dot for light
        renderLight();

        lightMapCtx.clearRect(0, 0, 640, 480);
        lightSourceMapCtx.clearRect(0, 0, 640, 480);

        shadowMapCtx.clearRect(0, 0, 640, 480);
        shadowMapCtx.fillStyle = "rgba(0,0,0,0.95)";	// Ambient light
        shadowMapCtx.fillRect(0, 0, 640, 480);


        // Draw shadowMap
        renderLightSource(48, 48);
        renderLightSource(lightX, lightY);


        shadowMapCtx.globalCompositeOperation = "destination-out";
        shadowMapCtx.drawImage(lightMap, 0, 0);
        shadowMapCtx.globalCompositeOperation = "source-over";


        //lightMapCtx.globalCompositeOperation = "source-out";
        lightMapCtx.drawImage(lightSourceMap, 0, 0);
        //lightMapCtx.globalCompositeOperation = "source-over";


        // Cut the shadows out of the light
        lightSourceMapCtx.globalCompositeOperation = "destination-out";
        lightSourceMapCtx.drawImage(shadowMap, 0, 0);
        lightSourceMapCtx.globalCompositeOperation = "source-over";

        // Draw Fog
        fogCtx.clearRect(0, 0, 640, 480);
        fogCtx.fillStyle = "rgba(0,0,0,0.5)";	// Ambient light
        fogCtx.fillRect(0, 0, 640, 480);

        // Cut the light out of the fog
        fogCtx.globalCompositeOperation = "destination-out";
        fogCtx.drawImage(lightSourceMap, 0, 0);
        fogCtx.drawImage(lightSourceMap, 0, 0);
        fogCtx.drawImage(lightSourceMap, 0, 0);
        fogCtx.globalCompositeOperation = "source-over";


        // Draw the actual map
        ctx.clearRect(0, 0, 640, 480);
        ctx.fillStyle = "#ffcccc"
        ctx.fillRect(0,0,640,480)
        //renderMap();

        ctx.drawImage(lightMap, 0, 0);
        ctx.drawImage(lightSourceMap, 0, 0);
        ctx.drawImage(shadowMap, 0, 0);
        //ctx.drawImage(fog, 0, 0);


        // Visual circle
        //ctx.globalCompositeOperation = "destination-in";
        //ctx.drawImage(visCircle, lightX - 160, lightY - 160);
        //ctx.globalCompositeOperation = "source-over";
    }
    render();


    function renderLightSource(x, y) {
        renderRay(x, y);
        renderRay(x+5, y);
        renderRay(x-5, y);
        renderRay(x, y+5);
        renderRay(x, y-5);

        // Draw lightSourceMap
        lightSourceMapCtx.drawImage(visCircle, x - 160, y - 160);
    }


    function findCorners() {
        // Find the corners
        corners = [];

        for (var y = 0; y < mapHeight; y++) {
            for (var x = 0; x < mapWidth; x++) {

                // Skip edges?
                if (y === 0 || x === 0 || y === mapHeight-1 || x === mapWidth-1) {
                    continue;
                }

                // Check top left
                if (
                    (map[y][x] && !map[y][x-1] && !map[y-1][x] && !map[y-1][x-1]) ||
                    !map[y][x] && map[y-1][x] && map[y][x-1] && map[y-1][x-1]
                    ) {
                    corners.push({
                        x: x * tileWidth,
                        y: y * tileHeight
                    });
                }

                // Check top right
                if (
                    (map[y][x] && !map[y][x+1] && !map[y-1][x] && !map[y-1][x+1]) ||
                    (!map[y][x] && map[y-1][x] && map[y][x+1] && map[y-1][x+1])
                    ) {
                    corners.push({
                        x: (x+1) * tileWidth,
                        y: y * tileHeight
                    });
                }

                // Check bottom left
                if (
                    (map[y][x] && !map[y][x-1] && !map[y+1][x] && !map[y+1][x-1]) ||
                    (!map[y][x] && map[y+1][x] && map[y][x-1] && map[y+1][x-1])
                ) {
                    corners.push({
                        x: x * tileWidth,
                        y: (y+1) * tileHeight
                    });
                }

                // Check bottom right
                if (
                    (map[y][x] && !map[y][x+1] && !map[y+1][x] && !map[y+1][x+1]) ||
                    (!map[y][x] && map[y+1][x] && map[y][x+1] && map[y+1][x+1])
                    ) {
                    corners.push({
                        x: (x+1) * tileWidth,
                        y: (y+1) * tileHeight
                    });
                }
            }
        }
    }

    function drawCorner(x, y) {
        ctx.fillStyle = "yellow";
        ctx.beginPath()
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
    }


    function renderMap() {
        ctx.strokeStyle = "#eee";
        ctx.fillStyle = "#999";
        for (var y = 0; y < mapHeight; y++) {
            for (var x = 0; x < mapWidth; x++) {
                if (map[y][x]) {
                    ctx.fillRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
                } else {
                    ctx.strokeRect(x * tileWidth, y * tileHeight, tileWidth, tileHeight);
                }
            }
        }
    }

    function renderLight() {
        ctx.fillStyle = "red";
        ctx.beginPath()
        ctx.arc(lightX, lightY, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath()
        ctx.arc(lightX-5, lightY, 1, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath()
        ctx.arc(lightX+5, lightY, 1, 0, Math.PI * 2);
        ctx.fill();
    }

    function renderRay(vX, vY) {
        intersections = [];

        for (var c = 0, m = corners.length; c < m; c++) {
            drawCorner(corners[c].x, corners[c].y);
            var angle = 0.1;

            rayTraceByAngle(vX, vY, corners[c].x, corners[c].y, 0-angle);
            rayTrace(vX, vY, corners[c].x, corners[c].y);
            rayTraceByAngle(vX, vY, corners[c].x, corners[c].y, angle);
        }

        // Calculate angles
        for (var i = 0, m = intersections.length; i < m; i++) {
            var dX = vX - intersections[i].x;
            var dY = vY - intersections[i].y;
            intersections[i].angle = Math.atan2(dX, dY);
        }

        // Sort by angle
        intersections.sort(function (a, b) {
            return a.angle - b.angle;
        });


        // Draw triangles
        //shadowMapCtx.globalCompositeOperation = "destination-out";
        lightMapCtx.fillStyle = "rgba(255,255,255,0.3)";
        lightMapCtx.beginPath();
        lightMapCtx.moveTo(intersections[0].x, intersections[0].y);

        for (var i = 0, m = intersections.length; i < m; i++) {
            if (i === 0) {
                lightMapCtx.lineTo(intersections[m-1].x, intersections[m-1].y);
            } else {
                lightMapCtx.lineTo(intersections[i-1].x, intersections[i-1].y);
            }
        }

        lightMapCtx.fill();
        //shadowMapCtx.globalCompositeOperation = "source-over";

    }

    function rayTraceByAngle(x0, y0, x1, y1, angle) {
        var px = Math.cos(angle) * (x1 - x0) - Math.sin(angle) * (y1 - y0) + x0;
        var py = Math.sin(angle) * (x1 - x0) + Math.cos(angle) * (y1 - y0) + y0;

        rayTrace(x0, y0, px, py);
    }

    function rayTrace(x0, y0, x1, y1) {
        var dx = Math.abs(x1 - x0);
        var dy = Math.abs(y1 - y0);
        var x = x0;
        var y = y0;
        //var n = 1 + dx + dy;
        var n = 1000;	// max draw distance
        var xInc = (x1 > x0) ? 1 : -1;
        var yInc = (y1 > y0) ? 1 : -1;
        var error = dx - dy;
        dx = dx * 2;
        dy = dy * 2;

        for (; n > 0; --n) {

            var mX = Math.floor(x / tileWidth);
            var mY = Math.floor(y / tileHeight);

            if (map[mY] && map[mY][mX]) {
                intersections.push({
                    x: x,
                    y: y
                });
                break;
            }

            if (error > 0) {
                x += xInc;
                error -= dy;
            } else {
                y += yInc;
                error += dx;
            }

        }
    }

</script>
</body>
</html>